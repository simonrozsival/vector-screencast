\chapter{Analysis}

The overall project consists of two separate tools --- the \textit{recorder} and the \textit{player}. Each of these tools behaves differently and will be used by different people. While the video player will be used by general audience, the recorder will be used by a much narrower group of content creators.

The recording tool will capture the movement of a virtual chalk and lines drawn on a virtual blackboard, as well as voice of the author using a microphone. The recorder data will be then sent to the server, where it should be stored. The player will receive previously recorded data and display the movement of the chalk and lines created by the author while playing the voice commentary.

For the purposes of recording, the tool must be able to capture the input from a microphone, track mouse movement and left mouse button state, collect information from Wacom graphics tablet devices and draw lines on screen. What the creator sees should be the same as what the end user will watch later.

\section{Available techonologies}
Web is a huge and fast growing environment. In only a few years, it has become a universal place for presenting and exchanging information. This put web in the focus of many software companies and organizations and as a result, many different technologies for developing \textit{Rich Internet Applications} (RIA) have been created. Some of them have already faded into obscurity, other are just emerging. One of the main limitations in the selection of the right technology for developing web application is their compatibility with different operating systems and web browsers.

\subsection{Java applets}
Java applets are used for creating interactive applications within web browsers \cite{java}. Java applets meet all the specified technical requirements of both player and recording tool.

Java applets are written in any language, that can be compiled into bytecode, this bytecode is then downloaded to the web browser and then runs using Java Virtual Machine (JVM). This means that to be able to run a Java applet, user needs to have JVM installed on the device and an installed and allowed Java plugin in his web browser. There is no support for mobile operating systems such as iOS and Android \cite{java_mobile} and Google Chrome has Java disabled by default in most recent versions  for security reasons.

\subsection{Adobe Flash}
Adobe Flash is a multimedia and software platform used for creating vector graphics, animations and games. Flash has all required features: vector graphics manipulation, working with Extensible Markup Language (XML)\footnote{http://www.w3.org/XML/}, mouse input capturing, microphone input, and audio streaming \cite{flash}. 

To view Flash animations or to execute Flash applications, Adobe Flash Player is needed. Adobe Flash Player is available and being developed for all major operating systems, although that is not true for mobile platforms. There was never any support for Apple iOS \cite{steve_jobs} and in 2012 development of Flash for Android was discontinued \cite{flash_mobile}. Using Adobe Flash would mean to exclude most users of tablets and smartphones \cite{mobile_statistics}, which is a large disadvantage of this technology.

\subsection{Microsoft Silverlight}
\textit{Microsoft Silverlight} \cite{silverlight} can be used for creating web applications. It is based on the .NET Framework and it is similar to Java applets and Adobe Flash. It was Microsoft's attempt to compete Adobe Flash, but has not gained much popularity. Development of Silverlight was also discontinued by Microsoft in 2012 and it will not be supported in Microsoft's new web browser Microsoft Edge\cite{silverlight_is_dead}. These facts make Silverlight unsuitable for this project.


\subsection{HTML5}
\textit{HTML5} is the fifth revision of \textit{HyperText Markup Language} (HTML) standard by the \textit{World Wide Web Consortium} (W3C). It has been given the Recommendation status in the end of 2014 and all crutial aspects of both tools can be implemented using the proposed standard. Tracking mouse was long supported even in HTML and ECMAScript/JavaScript\footnote{ECMAScript is familiarly known as JavaScript after it's most common implementation\cite{javascript_vs_ecmascript}} through \textit{Document Object Model} (DOM) Events\cite{dom_mouse_events}.

Vector graphics are supported through the \textit{Scalable Vector Graphics} (SVG) format \cite{svg} and it can be manipulated through DOM API \cite{dom}, as well as any other XML content. MediaStream API \cite{} enables access to audio input from user's microphone. The \verb|<audio>| tag can be used to stream audio files and play them in a web browser.

While HTML5 is a new standard, many of the most important features have already been implemented in some web browsers, like Google Chrome and Mozilla Firefox. More specifically, all the features needed to implement screencast player are supported in the latest versions of all major web browsers. The only catch might be disagreement on supported audio file formats among the creators of web browsers. This can be overcome by converting the audio into several used formats and passing them to the browser, which will then choose the one it supports.

Some of the features needed by the recording tool, like the MediaStream API, are not supported by all web browsers yet, but this won't be an issue for content creators, who can easily install a supported web browser on all desktop platforms and even some mobile ones. Fast development in this area is expected and these features will be most likely soon implemented in the next versions of all major browsers.

\subsubsection*{Scalable Vector Graphics (SVG) and Synchronized Multimedia Integration Language (SMIL)}
\paragraph{SVG} SVG is an XML based file format designed for describing two-dimensional vector images\cite{svg}. It is an open format developed and maintained by the W3C SVG Working Group \cite{}. Current W3C Recommendation is SVG 1.1 (Second Edition).

\paragraph{SMIL} \textit{SMIL} is an estabelished standard for animation of SVG images using a declarative approach. It is an extension of SVG specification that lets the user to define key-frame animations of SVG elements' attributes. SMIL is not supported by all major browsers\footnote{https://status.modern.ie/svgsmilanimation}. SMIL's future is unsure at the moment, as Blink rendering engine development team has announced to deprecate the technology in Chromium and Google Chrome in favor of CSS animations and the \textit{Web Animation API} \cite{} \footnote{https://www.chromestatus.com/features/5371475380928512}. 

\subsubsection*{Web Animation API}
A very promising technology is the \textit{Web Animation API} \footnote{http://www.w3.org/TR/web-animations/}, which will provide a very effective way of declaring and controlling animations in a web page through a JavaScript API. This technology is currently (3rd July 2015) in the state of Editor's Draft. This means that it is provided for discussion only and may change at any moment \cite{} \footnote{http://w3c.github.io/web-animations/}.

Unfortunatelly, at the time of writing this thesis, is not supported by several major browsers\footnote{https://status.modern.ie/webanimationsjavascriptapi}\footnote{} and is only partially supported in the remaining few \footnote{http://caniuse.com/\#feat=web-animation}\footnote{https://birtles.github.io/areweanimatedyet/}.

\subsection{Conclusion}
The bottleneck of most of the technologies is their support in mobile devices. These devices don't allow some of the above mentioned technologies to run inside them. As the popularity and market share of mobile devices grow, supporting them is a high priority. HTML5 APIs features needed to create the screencast player are implemented all major web browsers, including browsers for mobile devices. Audio recording is not supported by all major browsers at the moment, but this will change with the release of Microsoft Edge \cite{}\footnote{http://blogs.windows.com/msedgedev/2015/05/13/announcing-media-capture-functionality-in-microsoft-edge/}. After considering these facts, HTML5 was selected to implement both the recording tool and the screencast player.

\subsection{Possible issues and known limitations}
As mentioned earlier, not all browsers implement all features described in the HTML5 specification in their latest versions. But the trend is to implement as many technologies as possible to bring better browsing experience to users to gain bigger market share, so this situation will get better soon.

Another fact, that might cause trouble, is that many users still use an old version of their browser. This is mainly the case of Microsoft Internet Explorer (MSIE), which does not have automatic update mechanism. Fortunatelly, the number of MSIE users is dropping and Microsoft Edge, the ancestor of MSIE, will have automatic updates built in (@todo: some relevant source).

So far, there hasn't been consensus on formats and codecs support in HTML5 \textit{WebAudio API}. The most supported format across web browsers is MP3. This format isn't supported by some browsers on some platforms due to licence reasons. An up-to-date table with media formats' support can be found at \textit{Mozzila Developer Network} (MDN) website  \cite{} \footnote{https://developer.mozilla.org/en-US/docs/Web/HTML/Supported\_media\_formats}. This inconvenience can be easily solved by providing several \verb|<source>| elements to the \verb|<audio>| element with different formats. Browser will then select the format it supports and it will download and play this audio track. The flaw is the need of having the data stored in several formats on the server and the video as a whole takes more disk capacity.





\section{Drawing algorithm}
One of the key aspects of success of this library is the way it draws the lines. The lines must be nice, smooth and feel natural, as if somebody physically drew them on a blackboard with a chalk, and must not be disturbing or distracting. This library cannot improve the contents of the author's video, but the way it is displayed to the user can have possitive impact on viewer's impression of the video. It is also required that stylus pressure has direct proportion to the width of the drawn line.

After a research, the algorithm called ``Dynadraw'' by Paul Haeberli \cite{dyna_draw} from 1989, seems appropriate for this project. It is for example used in \textit{Inkscape}\footnote{Inkscape: http://inkscape.org} for the calligraphic tool\footnote{http://bazaar.launchpad.net/~inkscape.dev/inkscape/trunk/view/head:/src/ui/tools/calligraphic-tool.h}.

This algorithm models the tip of the brush as a physical object and simulates its movement. User applies force on the brush by moving the mouse or any other pointing device. The original algorithm is designed for calligraphic strokes and uses mouse speed to calculate dynamic line widths. This technique makes lines drawn by a mouse or other pressure-insensitive device more interesting and can be combined with pressure level of pressure-sensitive device.

For details of the implementation see section~\ref{sec:dynadraw} on page \pageref{sec:dynadraw}.



\section{Audio recording}
Audio input from the microphone will have the form of raw uncompressed \textit{Pulse-code modulated} (PCM) data\cite{mic_pcm}. The sample rate is chosen by the web browser and cannot be changed by the programmer. The sample rate must be between 22.05 to 96 kHz. If we choose the bit depth of 16 bits per sample, then we can calculate the minimum data load of uncompressed audio recording. Therefore we receive at least 44.1 kB of data per second, which 2.646 MB of data per minute of recording. From experience, desktop browsers target 44.1 kHz sampling rate, which even doubles the data load. This data must be uploaded to the server so users can watch the screencasts with voice commentary.

\paragraph{Buffering microphone input} The first possible approach is to buffer all data from the microphone, create an uncompressed audio file and upload this file to the server at the end of the recording. Creating a \textit{Waveform Audio File Format} (WAVE or WAV) file is relatively simple because it contains only a simple header and LPCM data.

\paragraph{Compression of buffered data in the browser} The uncompressed audio is relatively large and the upload will take much more time, then uploading a compressed file would take. Audio compression is a complex process. There are several JavaScript libraries, that implement audio compression inside a web browser\footnote{http://bgrins.github.io/videoconverter.js/}\footnote{https://github.com/akrennmair/libmp3lame-js}, but they have shown to be large, slow and unstable.

\paragraph{Streaming microphone data to the server in background} A different method is possible with the use of the \textit{WebSocket protocol}. The WebSocket protocol enables two-way communication between a client and a server \cite{websocket}. It is built on top of \textit{Transmission Control Protocol} (TCP) sockets, which means it provides ordered and reliable transmission of messages. Either textual or binary messages can be sent over a WebSocket. If the data is transfered over the WebSocket at the time of recording in background, then a considerable part of the data might be already uploaded to the server as soon as the user stops recording, depending on his Internet connection upstream speed.

\subsection{Conclusion}
Streaming the recorded audio data in background over a WebSocket seems to be convenient for the user. It will fasten the uploading process at the end of recording, as part of the audio data is already uploaded before the user even clicks the upload button.

Server must implement WebSocket connections and serve clients. Server might also use a native program, like the open-source FFmpeg\footnote{https://www.ffmpeg.org} to compress the audio and convert it to different file formats.

\section{File format}
Recorded data must be stored in a data storage, so it can be played later. Vector video file must contain all the information about cursor movement and precise data of the lines, including their variable width, and the times at which every single segment of a line is drawn. This data is then used to reconstruct the precise movement of the author's cursor and draw the very sqme lines at the very same pace.

\paragraph{EVA} There are several existing vector based formats available for animations. One of them is \textit{EVA} by SHARP\cite{eva_sharp} developed in 1996. EVA is a binary format popular in Japan. Unfortunatelly the documentation and resourcecs are available only in Japanese\cite{eva_wikipedia}.

\paragraph{SWF} Another well-known format is Adobe's \textit{SWF}. It is a binary format with a wide rage of usage. It can contain either bitmap-based video, vector primitives, and ActionScript\cite{swf_wiki}. It is possible to manipulate contained vector primitives and morph their properties to create a key-frame animation\cite{swf_doc}. Documentation of the format is open since 2008.

\paragraph{SVG} \textit{Scalable Vector Graphics} was already mentioned earlier. This format can contain SMIL animation definitions, which makes it also a vector animation format. SVG is based on XML and it is therefore a human-readable textual format. As discussed earlier SMIL animations are not considered a good option for this project.

\paragraph{Custom extension of SVG} JavaScript is not very good at manipulating binary files. Until the specification of typed arrays\footnote{https://www.khronos.org/registry/typedarray/specs/latest/}, manipulating binary files in JavaScript was very ineffective and unintuitive. Even with these new technologies, working with XML in JavaScript is more straighforward. The fact, that SVG is based on XML means, that it can be extended with custom namespace and define custom animation, that will be better for this project.

\subsection{Conclusion}
After considering available options, creating a custom format based on SVG seems like the best option for it's human-readability, simplicity, versatility, ease of manipulation using JavaScript, and the possibility of previewing static scenes of the animation in existing software. This format will serve well as a proof-of-concept and can be replaced with a more sophisticated format in the future and the format must not be therefore hard-coded into the library.

For the specification of this new format, see chapter~\ref{c:the-format} on page~\pageref{c:the-format}.